{"version":3,"sources":["../src/index.ts","../src/dispatch.ts","../src/auth.ts","../src/queue.ts","../src/utils/error.ts","../src/api.ts","../src/stream.ts","../src/utils/partial.ts","../src/utils/transcoding.ts","../src/utils/playlist.ts","../src/utils/validate.ts","../src/info.ts","../src/utils/permalink.ts"],"sourcesContent":["export * from \"./api\";\nexport * from \"./auth\";\nexport {\n    getAgent,\n    getRequestTimeout,\n    setAgent,\n    setRequestTimeout\n} from \"./dispatch\";\nexport {\n    CreatorSubscription,\n    PartialTrackInfo,\n    PublisherMetadata,\n    StreamableTrackInfo,\n    StreamableTrackInfoData,\n    TrackInfo,\n    TrackInfoData,\n    TrackMedia,\n    UserBadges,\n    UserInfo,\n    Visual,\n    Visuals,\n    getInfo,\n    getPlaylistInfo\n} from \"./info\";\nexport { getRequestQueueLimit, setRequestQueueLimit } from \"./queue\";\nexport {\n    StreamOptions,\n    TrackStream,\n    stream,\n    streamFromInfo,\n    streamFromInfoSync,\n    streamPlaylist,\n    streamPlaylistFromInfo,\n    streamPlaylistFromInfoSync,\n    streamSync\n} from \"./stream\";\nexport * from \"./utils/partial\";\nexport * from \"./utils/permalink\";\nexport type {\n    PlaylistInfo,\n    PlaylistInfoData,\n    StreamablePlaylistInfo\n} from \"./utils/playlist\";\nexport * from \"./utils/transcoding\";\nexport * from \"./utils/validate\";\n","import { Readable } from \"stream\";\nimport { Dispatcher, getGlobalDispatcher } from \"undici\";\nimport { getClientID, getOauthToken } from \"./auth\";\nimport { Queue } from \"./queue\";\nimport { RawTrackStream } from \"./stream\";\nimport { RequestError, ScdlError } from \"./utils/error\";\n\nconst DEFAULT_TIMEOUT = 30000;\nconst queue = new Queue();\nlet dispatcher: Dispatcher | null = null;\nlet requestTimeout: number | null = null;\n\n/**\n * Set the agent to use for requests\n * \n * Defaults to the global dispatcher\n */\nexport function setAgent(agent: Dispatcher): void {\n    dispatcher = agent;\n}\n\n/**\n * Get the currently set agent\n */\nexport function getAgent(): Dispatcher {\n    return dispatcher ?? getGlobalDispatcher();\n}\n\n/**\n * Set the timeout for requests in milliseconds\n * \n * Defaults to 30000 ms\n */\nexport function setRequestTimeout(timeout: number): void {\n    requestTimeout = timeout;\n}\n\n/**\n * Get the timeout for requests in milliseconds\n */\nexport function getRequestTimeout(): number {\n    return requestTimeout ?? DEFAULT_TIMEOUT;\n}\n\n/**\n * Create GET request options from a URL\n */\nfunction createRequestOptions(url: URL): Dispatcher.RequestOptions {\n    const options: Dispatcher.RequestOptions = {\n        origin: url.origin,\n        path: url.pathname + url.search,\n        method: \"GET\"\n    };\n    const timeout = getRequestTimeout();\n    options.headersTimeout = timeout;\n    options.bodyTimeout = timeout;\n    return options;\n}\n\n/**\n * Perform a GET request\n */\nexport async function request(url: URL): Promise<Dispatcher.ResponseData> {\n    await queue.enqueue();\n    try {\n        const res = await getAgent()\n            .request(createRequestOptions(url));\n        if (res.statusCode < 400) {\n            return res;\n        }\n        else {\n            throw new RequestError(res.statusCode);\n        }\n    }\n    finally {\n        queue.dequeue();\n    }\n}\n\n/**\n * Perform a GET request with authentication and parse as JSON\n */\nexport async function requestWithAuth(url: string | URL): Promise<any> {\n    const parsedUrl = new URL(url);\n    switch (true) {\n        case !!getOauthToken():\n            parsedUrl.searchParams.set(\"oauth_token\", getOauthToken()!);\n            break;\n        case !!getClientID():\n            parsedUrl.searchParams.set(\"client_id\", getClientID()!);\n            break;\n        default:\n            throw new ScdlError(\"Authentication not set\");\n    }\n    parsedUrl.hash = \"\";\n    const { body } = await request(parsedUrl);\n    return body.json();\n}\n\n/**\n * Perform a GET request and output to an existing PassThrough\n * \n * Similar to `undici.stream`, but resolves on completion rather than\n * stream consumption\n * @param url The URL perform a request to\n * @param output The stream to write to\n * @param end Whether to end the writer on completion\n * @returns The output stream\n */\nexport async function streamThrough(\n    url: URL,\n    output: RawTrackStream,\n    end: boolean = true\n): Promise<Readable> {\n    return new Promise(async (resolve, reject) => {\n        function cleanup(): void {\n            queue.dequeue();\n            if (end) {\n                output.end();\n            }\n        }\n\n        await queue.enqueue();\n        getAgent()\n            .dispatch(createRequestOptions(url), {\n                onConnect: () => output.emit(\"connect\"),\n                onHeaders: statusCode => {\n                    if (statusCode < 400) {\n                        return true;\n                    }\n                    else {\n                        cleanup();\n                        reject(new RequestError(statusCode));\n                        return false;\n                    }\n                },\n                onData: chunk => {\n                    output.write(chunk);\n                    return true;\n                },\n                onComplete: () => {\n                    cleanup();\n                    resolve(output);\n                },\n                onError: err => {\n                    cleanup();\n                    reject(err);\n                }\n            });\n    });\n}\n","let clientID: string | null = null;\nlet oauthToken: string | null = null;\n\n/**\n * Set the client_id to access the API with\n */\nexport function setClientID(id: string | null): void {\n    clientID = id;\n}\n\n/**\n * Set the oauth_token to access the API with\n * \n * This will be prioritized over a client_id\n */\nexport function setOauthToken(token: string | null): void {\n    oauthToken = token;\n}\n\n/**\n * Get the currently set client_id\n */\nexport function getClientID(): string | null {\n    return clientID;\n}\n\n/**\n * Get the currently set oauth_token\n */\nexport function getOauthToken(): string | null {\n    return oauthToken;\n}\n","const DEFAULT_MAX = 20;\nlet queueMax: number | null = null;\n\n/**\n * Set the limit for concurrent requests\n * \n * Defaults to 20\n */\nexport function setRequestQueueLimit(limit: number): void {\n    queueMax = limit;\n}\n\n/**\n * Get the limit for concurrent requests\n */\nexport function getRequestQueueLimit(): number {\n    return queueMax ?? DEFAULT_MAX;\n}\n\n/**\n * Internal request queue\n */\nexport class Queue {\n    private current: number;\n    private queue: (() => void)[];\n\n    constructor() {\n        this.current = 0;\n        this.queue = [];\n    }\n\n    /**\n     * Wait for this to resolve before executing a queued action\n     */\n    async enqueue(): Promise<void> {\n        if (this.current >= getRequestQueueLimit()) {\n            await new Promise<void>(resolve => this.queue.unshift(resolve));\n        }\n        this.current++;\n    }\n\n    /**\n     * Call this after a queued action has finished executing\n     */\n    dequeue() {\n        this.current--;\n        const next = this.queue.pop();\n        next?.();\n    }\n}\n","import { STATUS_CODES } from \"http\";\n\nclass CustomError extends Error {\n    constructor(message?: string) {\n        super(message);\n        this.name = this.constructor.name;\n    }\n}\n\nexport class ScdlError extends CustomError { }\n\nexport class RequestError extends CustomError {\n    constructor(statusCode: number) {\n        super(`${statusCode} ${STATUS_CODES[statusCode]}`);\n    }\n}\n","import { requestWithAuth } from \"./dispatch\";\n\nconst RESOLVE_ENDPOINT = \"https://api-v2.soundcloud.com/resolve\";\n\n/**\n * Resolve info from a URL\n */\nexport async function rawResolve(url: string): Promise<any> {\n    const endpoint = new URL(RESOLVE_ENDPOINT);\n    endpoint.searchParams.set(\"url\", url);\n    return requestWithAuth(endpoint);\n}\n","import { M3uParser } from \"m3u-parser-generator\";\nimport { PassThrough, Readable } from \"stream\";\nimport {\n    request,\n    requestWithAuth,\n    streamThrough\n} from \"./dispatch\";\nimport {\n    StreamableTrackInfo,\n    StreamableTrackInfoData,\n    getInfo,\n    getPlaylistInfo\n} from \"./info\";\nimport { ScdlError } from \"./utils/error\";\nimport { FetchablePlaylistInfo, fetchPartialPlaylist } from \"./utils/partial\";\nimport { StreamablePlaylistInfo } from \"./utils/playlist\";\nimport {\n    MimeType,\n    Preset,\n    Protocol,\n    Quality,\n    Transcoding\n} from \"./utils/transcoding\";\n\nconst DEFAULT_OPTIONS: StreamOptions = {\n    strict: false,\n    preset: Preset.MP3,\n    protocol: Protocol.PROGRESSIVE,\n    mimeType: MimeType.MPEG,\n    quality: Quality.SQ\n};\n\nconst OPTION_WEIGHT: Record<keyof TranscodingOptions, number> = {\n    mimeType: 1,\n    preset: 1.1,\n    protocol: 1.2,\n    quality: 1.3\n};\n\nasync function streamHls(url: URL, output: PassThrough): Promise<Readable> {\n    const hlsRes = await request(url);\n    const parser = new M3uParser();\n    const { medias } = parser.parse(await hlsRes.body.text());\n    for (const media of medias) {\n        await streamThrough(new URL(media.location), output, false);\n    }\n    return output.end();\n}\n\n/**\n * Create a stream from a transcoding object\n * @param transcoding The transcoding to stream\n * @param output Existing output stream from `streamSync`\n * @returns The output stream, previously existing or not\n */\nasync function streamTranscoding(transcoding: Transcoding, output?: PassThrough): Promise<TrackStream> {\n    const { url: streamUrl }: TranscodingStreamResponse = await requestWithAuth(transcoding.url);\n    const url = new URL(streamUrl);\n    const outStream: RawTrackStream = output ?? new PassThrough();\n    outStream.transcoding = transcoding;\n    outStream.emit(\"transcoding\", transcoding);\n    const streaming = transcoding.format.protocol === Protocol.HLS ?\n        streamHls(url, outStream) :\n        streamThrough(url, outStream);\n    if (output) {\n        streaming.catch(err => outStream.emit(\"error\", err));\n    }\n    else {\n        await streaming;\n    }\n    return outStream;\n}\n\n/**\n * Find a transcoding that matches the given options\n * @param transcodings Transcodings obtained from a track's info\n * @param options Transcoding search options\n */\nfunction findTranscoding(transcodings: Array<Transcoding>, options: StreamOptions): Transcoding | null {\n    if (!transcodings.length) {\n        return null;\n    }\n    else if (options.strict) {\n        return transcodings.find(transcoding =>\n            (!options.preset || transcoding.preset === options.preset) &&\n            (!options.protocol || transcoding.format.protocol === options.protocol) &&\n            (!options.mimeType || transcoding.format.mime_type === options.mimeType) &&\n            (!options.quality || transcoding.quality === options.quality)\n        ) ?? null;\n    }\n    else {\n        const { transcoding: best } = transcodings.reduce((currentBest: ScoredTranscoding, transcoding) => {\n            const data: TranscodingOptions = {\n                preset: transcoding.preset,\n                protocol: transcoding.format.protocol,\n                mimeType: transcoding.format.mime_type,\n                quality: transcoding.quality\n            };\n            const current: ScoredTranscoding = {\n                transcoding,\n                score: Object\n                    .keys(OPTION_WEIGHT)\n                    .reduce((score, key) => {\n                        if (data[<keyof TranscodingOptions>key] === options[<keyof TranscodingOptions>key]) {\n                            score += OPTION_WEIGHT[<keyof TranscodingOptions>key];\n                        }\n                        return score;\n                    }, 0)\n            };\n            return current.score > currentBest.score ? current : currentBest;\n        }, {\n            transcoding: null,\n            score: 0\n        });\n        return best ?? transcodings[0];\n    }\n}\n\n/**\n * Underlying transcoding resolution and stream dispatch\n * \n * Not exportable\n * @param info Info obtained from `getInfo`\n * @param options Transcoding search options\n * @param output Existing output stream from `streamSync`\n */\nasync function streamEngine(\n    info: StreamableTrackInfoData,\n    options: StreamOptions,\n    output?: PassThrough\n): Promise<TrackStream> {\n    if (info.streamable === false) {\n        throw new ScdlError(\"Track not streamable\");\n    }\n    const transcoding = findTranscoding(info.media.transcodings, options);\n    if (transcoding) {\n        return streamTranscoding(transcoding, output);\n    }\n    else {\n        throw new ScdlError(\"Failed to obtain transcoding\");\n    }\n}\n\n/**\n * * Stream a track from its info object\n * \n * Used internally by `stream`\n * @param info Info obtained from `getInfo`\n * @param options Transcoding search options\n */\nexport async function streamFromInfo(info: StreamableTrackInfo, options: StreamOptions = DEFAULT_OPTIONS): Promise<TrackStream> {\n    return streamEngine(info.data, options);\n}\n\n/**\n * Stream a track from its URL\n * @param url A track URL\n * @param options Transcoding search options\n */\nexport async function stream(url: string, options: StreamOptions = DEFAULT_OPTIONS): Promise<TrackStream> {\n    const info = await getInfo(url);\n    return streamFromInfo(info, options);\n}\n\n/**\n * Synchronously stream a track from its URL\n * @param url A track URL\n * @param options Transcoding search options\n */\nexport function streamSync(url: string, options: StreamOptions = DEFAULT_OPTIONS): TrackStream {\n    const output = new PassThrough();\n    getInfo(url)\n        .then(info => streamEngine(info.data, options, output))\n        .catch(err => output.emit(\"error\", err));\n    return output;\n}\n\n/**\n * Synchronously stream a track from its info object\n * @param info Info obtained from `getInfo`\n * @param options Transcoding search options\n */\nexport function streamFromInfoSync(info: StreamableTrackInfo, options: StreamOptions = DEFAULT_OPTIONS): TrackStream {\n    const output = new PassThrough();\n    streamEngine(info.data, options, output)\n        .catch(err => output.emit(\"error\", err));\n    return output;\n}\n\n/**\n * Stream tracks from a playlist's info object\n * \n * Fetches partial track data before streaming\n * \n * Used internally by `streamPlaylist` and `PlaylistInfo.stream`\n * @param info Info obtained from `getPlaylistInfo`\n * @param options Transcoding search options\n * @returns A promise that resolves in an array. Each item will be either a readable stream or `null` if streaming errored\n */\nexport async function streamPlaylistFromInfo(info: StreamablePlaylistInfo | FetchablePlaylistInfo, options: StreamOptions = DEFAULT_OPTIONS): Promise<Array<TrackStream | null>> {\n    await fetchPartialPlaylist(info as FetchablePlaylistInfo);\n    return Promise.all(\n        info.data.tracks.map(async track => {\n            try {\n                return await streamEngine(track as StreamableTrackInfoData, options);\n            }\n            catch {\n                return null;\n            }\n        })\n    );\n}\n\n/**\n * Stream tracks from a playlist's URL\n * @param url A playlist URL\n * @param options Transcoding search options\n * @returns A promise that resolves in an array. Each item will be either a readable stream or `null` if streaming errored\n */\nexport async function streamPlaylist(url: string, options: StreamOptions = DEFAULT_OPTIONS): Promise<Array<TrackStream | null>> {\n    const info = await getPlaylistInfo(url);\n    return streamPlaylistFromInfo(info, options);\n}\n\n/**\n * Synchronously stream tracks from a playlist's info object\n * @param info Info obtained from `getPlaylistInfo`\n * @param options Transcoding search options\n */\nexport function streamPlaylistFromInfoSync(info: StreamablePlaylistInfo, options: StreamOptions = DEFAULT_OPTIONS): Array<TrackStream> {\n    return info.data.tracks.map(track => {\n        const output = new PassThrough();\n        streamEngine(track, options, output)\n            .catch(err => output.emit(\"error\", err));\n        return output;\n    });\n}\n\ntype TranscodingOptions = {\n    preset: Preset,\n    protocol: Protocol,\n    mimeType: MimeType,\n    quality: Quality\n};\n\nexport type StreamOptions = Partial<TranscodingOptions> & {\n    /**\n     * If `true`, will only stream if all specified options match a transcoding\n     * \n     * If `false`, will stream most similar transcoding\n     * \n     * Defaults to `false`\n     */\n    strict?: boolean\n};\n\ntype ScoredTranscoding = {\n    transcoding: Transcoding | null,\n    score: number\n};\n\ntype TranscodingStreamResponse = {\n    url: string\n};\n\ninterface Emitter<EventMap extends Record<string, any[]>> {\n    emit<Event extends keyof EventMap>(event: Event, ...args: EventMap[Event]): boolean;\n    addListener<Event extends keyof EventMap>(event: Event, listener: (...args: EventMap[Event]) => any): this;\n    on<Event extends keyof EventMap>(event: Event, listener: (...args: EventMap[Event]) => any): this;\n    once<Event extends keyof EventMap>(event: Event, listener: (...args: EventMap[Event]) => any): this;\n    prependListener<Event extends keyof EventMap>(event: Event, listener: (...args: EventMap[Event]) => any): this;\n    prependOnceListener<Event extends keyof EventMap>(event: Event, listener: (...args: EventMap[Event]) => any): this;\n    removeListener<Event extends keyof EventMap>(event: Event, listener: (...args: EventMap[Event]) => any): this;\n    off(event: keyof EventMap, listener: (...args: any[]) => any): this;\n}\n\ntype TranscodingStreamEvents = {\n    transcoding: [Transcoding],\n    connect: []\n};\n\ninterface BaseTranscodingStream extends Emitter<TranscodingStreamEvents> {\n    transcoding?: Transcoding;\n}\n\nexport type RawTrackStream = BaseTranscodingStream & PassThrough;\n\nexport type TrackStream = BaseTranscodingStream & Readable;\n","import { rawResolve } from \"../api\";\nimport { DataWrapped, TrackInfoData } from \"../info\";\nimport { StreamablePlaylistInfo } from \"./playlist\";\n\n/**\n * Checks if all track data in a playlist has been fetched\n */\nexport function isPlaylistFetched(info: FetchablePlaylistInfo): info is StreamablePlaylistInfo & FetchablePlaylistInfo {\n    return info.data.tracks.every(track => \"media\" in track);\n}\n\n/**\n * Creates a track URI from a track's id\n * @param id The track's id\n */\nfunction trackURI(id: number): string {\n    return `https://api.soundcloud.com/tracks/${id}`;\n}\n\n/**\n * Fetches any partial track data in a playlist's info object\n * \n * Track info is updated in place\n * @param info Info obtained from `getPlaylistInfo`\n * @returns The updated playlist info object\n */\nexport async function fetchPartialPlaylist(info: FetchablePlaylistInfo): Promise<StreamablePlaylistInfo> {\n    info.data.tracks = await Promise.all(\n        info.data.tracks.map(async track => {\n            if (\"media\" in track) {\n                return track;\n            }\n            else {\n                const info: TrackInfoData = await rawResolve(trackURI(track.id));\n                return info;\n            }\n        })\n    );\n    return info as StreamablePlaylistInfo;\n}\n\nexport type MinimalTrackInfo = {\n    id: number;\n};\n\nexport type FetchablePlaylistInfoData = {\n    tracks: Array<TrackInfoData | MinimalTrackInfo>;\n};\n\nexport type FetchablePlaylistInfo = DataWrapped<FetchablePlaylistInfoData>;\n","export enum Preset {\n    MP3 = \"mp3_0_1\",\n    OPUS = \"opus_0_0\"\n}\n\nexport enum Protocol {\n    PROGRESSIVE = \"progressive\",\n    HLS = \"hls\"\n}\n\nexport enum MimeType {\n    MPEG = \"audio/mpeg\",\n    OPUS = \"audio/ogg; codecs=\\\"opus\\\"\"\n}\n\n/**\n * I've only seen `sq`, but I'm assuming there's a higher quality\n * for SoundCloud Go+ subscribers\n */\nexport enum Quality {\n    SQ = \"sq\"\n}\n\nexport type Transcoding = {\n    url: string;\n    preset: Preset;\n    duration: number;\n    snipped: boolean;\n    format: {\n        protocol: Protocol;\n        mime_type: MimeType;\n    };\n    quality: Quality;\n};\n","import {\n    DataWrapped,\n    PartialTrackInfo,\n    StreamableTrackInfoData,\n    TrackInfoData,\n    UserInfo\n} from \"../info\";\nimport { TrackStream, streamPlaylistFromInfo } from \"../stream\";\nimport { fetchPartialPlaylist, isPlaylistFetched } from \"./partial\";\n\nexport class PlaylistInfo<fetched extends boolean = boolean> {\n    constructor(public readonly data: PlaylistInfoData<fetched>) { }\n\n    /**\n     * Checks if all track data has been fetched\n     */\n    isFetched(): this is PlaylistInfo<true> {\n        return isPlaylistFetched(this);\n    }\n\n    /**\n     * Fetches any partial track data in this playlist\n     */\n    async fetchPartialTracks(): Promise<PlaylistInfo<true>> {\n        await fetchPartialPlaylist(this);\n        return this as PlaylistInfo<true>;\n    }\n\n    /**\n     * Stream tracks from this playlist\n     * \n     * Fetches partial track data first\n     */\n    async stream(): Promise<Array<TrackStream | null>> {\n        return streamPlaylistFromInfo(this);\n    }\n}\n\nexport type PlaylistInfoData<fetched extends boolean = boolean> = {\n    artwork_url?: string;\n    created_at: string;\n    description?: string;\n    duration: number;\n    embeddable_by: string;\n    genre?: string;\n    id: number;\n    kind: string;\n    label_name?: string;\n    last_modified: string;\n    license: string;\n    likes_count: number;\n    managed_by_feeds: boolean;\n    permalink: string;\n    permalink_url: string;\n    public: boolean;\n    purchase_title?: string;\n    purchase_url?: string;\n    release_date?: string;\n    reposts_count: number;\n    secret_token?: string;\n    sharing: string;\n    tag_list?: string;\n    title: string;\n    uri: string;\n    user_id: number;\n    set_type?: string;\n    is_album: boolean;\n    published_at?: string;\n    display_date: string;\n    user: UserInfo;\n    tracks: fetched extends true ? Array<TrackInfoData> : Array<TrackInfoData | PartialTrackInfo>;\n    track_count: number;\n};\n\nexport type StreamablePlaylistInfoData = {\n    tracks: Array<StreamableTrackInfoData>;\n};\n\nexport type StreamablePlaylistInfo = DataWrapped<StreamablePlaylistInfoData>;\n","/**\n * A regular expression that matches SoundCloud track URLs\n * \n * Includes the `user`, `title`, and `secret` groups\n */\nexport const TrackURLPattern = /^(?:https?:\\/\\/)?(?:www\\.)?soundcloud\\.com\\/(?<user>[\\w-]+)\\/(?!sets(?:$|[\\/?#]))(?<title>[\\w-]+)\\/?(?<secret>(?<=\\/)s-[A-Z0-9]+)?(?:(?<!\\/)\\/?)(?=[?#]|$)/i;\n\n/**\n * A regular expression that matches SoundCloud playlist URLs\n * \n * Includes the `user`, `title`, and `secret` groups\n */\nexport const PlaylistURLPattern = /^(?:https?:\\/\\/)?(?:www\\.)?soundcloud\\.com\\/(?<user>[\\w-]+)\\/sets\\/(?<title>[\\w-]+)\\/?(?<secret>(?<=\\/)s-[A-Z0-9]+)?(?:(?<!\\/)\\/?)(?=[?#]|$)/i;\n\n/**\n * Checks if a string matches the SoundCloud track URL format\n */\nexport function validateURL(url: string): boolean {\n    return TrackURLPattern.test(url);\n}\n\n/**\n * Checks if a string matches the SoundCloud playlist URL format\n */\nexport function validatePlaylistURL(url: string): boolean {\n    return PlaylistURLPattern.test(url);\n}\n","import { rawResolve } from \"./api\";\nimport { ScdlError } from \"./utils/error\";\nimport { PlaylistInfo, PlaylistInfoData } from \"./utils/playlist\";\nimport { Transcoding } from \"./utils/transcoding\";\nimport { validatePlaylistURL, validateURL } from \"./utils/validate\";\n\n/**\n * Get a track's info\n */\nexport async function getInfo(url: string): Promise<TrackInfo> {\n    if (validateURL(url)) {\n        const data: TrackInfoData = await rawResolve(url);\n        return { data };\n    }\n    else {\n        throw new ScdlError(\"Invalid track URL\");\n    }\n}\n\n/**\n * Get a playlist's info\n */\nexport async function getPlaylistInfo(url: string): Promise<PlaylistInfo> {\n    if (validatePlaylistURL(url)) {\n        const data: PlaylistInfoData = await rawResolve(url);\n        return new PlaylistInfo(data);\n    }\n    else {\n        throw new ScdlError(\"Invalid playlist URL\");\n    }\n}\n\nexport type TrackMedia = {\n    transcodings: Array<Transcoding>;\n};\n\nexport type DataWrapped<T> = {\n    data: T;\n};\n\nexport type StreamableTrackInfoData = {\n    streamable?: boolean;\n    media: TrackMedia;\n};\n\nexport type StreamableTrackInfo = DataWrapped<StreamableTrackInfoData>;\n\nexport type PublisherMetadata = {\n    id: number;\n    urn: string;\n    contains_music?: boolean;\n    artist?: string;\n    isrc?: string;\n    explicit?: boolean;\n    writer_composer?: string;\n    release_title?: string;\n    album_title?: string;\n    upc_or_ean?: string;\n    p_line?: string;\n    p_line_for_display?: string;\n    c_line?: string;\n    c_line_for_display?: string;\n    publisher?: string;\n    iswc?: string;\n};\n\nexport type Visual = {\n    urn: string;\n    entry_time: number;\n    visual_url: string;\n    link: string;\n};\n\nexport type Visuals = {\n    urn: string;\n    enabled: boolean;\n    visuals: Array<Visual>;\n    /**\n     * I have personally only seen this as `null`\n     */\n    tracking?: unknown;\n};\n\nexport type UserBadges = {\n    pro: boolean;\n    pro_unlimited: boolean;\n    verified: boolean;\n};\n\nexport type CreatorSubscription = {\n    product: {\n        id: string;\n    };\n};\n\nexport type UserInfo = {\n    avatar_url: string;\n    first_name?: string;\n    followers_count: number;\n    full_name?: string;\n    id: number;\n    kind: string;\n    last_modified: string;\n    last_name?: string;\n    permalink: string;\n    uri: string;\n    urn: string;\n    username: string;\n    verified: boolean;\n    city?: string;\n    country_code?: string;\n    badges: UserBadges;\n    station_urn: string;\n    station_permalink: string;\n    comments_count?: number;\n    created_at?: string;\n    creator_subscriptions?: Array<CreatorSubscription>;\n    creator_subscription?: CreatorSubscription;\n    description?: string;\n    followings_count?: number;\n    groups_count?: number;\n    likes_count?: number;\n    playlist_likes_count?: number;\n    playlist_count?: number;\n    reposts_count?: number;\n    track_count?: number;\n    visuals?: Visuals;\n};\n\nexport type PartialTrackInfo = {\n    id: number;\n    kind: string;\n    monetization_model: string;\n    policy: string;\n};\n\nexport type TrackInfoData = {\n    artwork_url?: string;\n    caption?: string;\n    commentable: boolean;\n    comment_count?: number;\n    created_at: string;\n    description?: string;\n    downloadable: boolean;\n    download_count?: number;\n    duration: number;\n    full_duration: number;\n    embeddable_by: string;\n    genre?: string;\n    has_downloads_left: boolean;\n    id: number;\n    kind: string;\n    label_name?: string;\n    last_modified: string;\n    license: string;\n    likes_count?: number;\n    permalink: string;\n    permalink_url: string;\n    playback_count?: number;\n    public: boolean;\n    publisher_metadata?: PublisherMetadata;\n    purchase_title?: string;\n    purchase_url?: string;\n    release_date?: string;\n    reposts_count: number;\n    secret_token?: string;\n    sharing: string;\n    state: string;\n    streamable: boolean;\n    tag_list?: string;\n    title: string;\n    track_format: string;\n    uri: string;\n    urn: string;\n    user_id: number;\n    visuals?: Visuals;\n    waveform_url: string;\n    display_date: string;\n    media: TrackMedia;\n    station_urn: string;\n    station_permalink: string;\n    track_authorization: string;\n    monetization_model: string;\n    policy: string;\n    user: UserInfo;\n};\n\nexport type TrackInfo = DataWrapped<TrackInfoData>;\n","import { PlaylistURLPattern, TrackURLPattern } from \"./validate\";\n\n/**\n * Formats a URL as a track's permalink URL\n */\nexport function getPermalinkURL(url: string): string {\n    const result = url.match(TrackURLPattern);\n    if (result) {\n        const publicURL = `https://soundcloud.com/${result.groups!.user}/${result.groups!.title}`;\n        return result.groups!.secret ? publicURL + `/${result.groups!.secret}` : publicURL;\n    }\n    else {\n        return \"\";\n    }\n}\n\n/**\n * Formats a URL as a playlist's permalink URL\n */\nexport function getPlaylistPermalinkURL(url: string): string {\n    const result = url.match(PlaylistURLPattern);\n    if (result) {\n        const publicURL = `https://soundcloud.com/${result.groups!.user}/sets/${result.groups!.title}`;\n        return result.groups!.secret ? publicURL + `/${result.groups!.secret}` : publicURL;\n    }\n    else {\n        return \"\";\n    }\n}\n"],"mappings":"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","names":["info","Preset","Protocol","MimeType","Quality"]}